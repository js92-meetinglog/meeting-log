name: Spring Boot CI/CD to AWS EC2

# 1. 트리거: 'main' 브랜치에 Push가 발생하면 실행
on:
  push:
    branches: [ "main" ]

jobs:
  # --------------------
  # 1. CI (빌드) 작업
  # --------------------
  build:
    runs-on: ubuntu-latest # 빌드 환경
    
    steps:
      # (1) 코드 체크아웃
      - name: Checkout
        uses: actions/checkout@v4

      # (2) JDK 21 설치
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      # (3) Gradle 실행 권한 부여
      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      # (4) Gradle로 빌드 (이때 application-local.properties는 사용되지 않음)
      - name: Build with Gradle
        run: ./gradlew build -x test

      # (5) 빌드된 .jar 파일을 'artifact'로 패키징
      #     (다음 deploy 작업에서 사용하기 위해)
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-jar # 아티팩트 이름
          path: build/libs/*.jar # 빌드된 jar 파일 경로

  # --------------------
  # 2. CD (배포) 작업
  # --------------------
  deploy:
    needs: build # 'build' 작업이 성공해야만 실행됨
    runs-on: ubuntu-latest
    
    steps:
      # (1) 'build' 작업에서 만든 'app-jar' 아티팩트 다운로드
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: build/libs # 다운로드 받을 경로

      # (2) EC2 서버로 .jar 파일 전송 (SCP)
      - name: SCP to EC2
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.AWS_HOST }}
          username: ${{ secrets.AWS_USERNAME }}
          key: ${{ secrets.AWS_SSH_KEY }}
          source: "build/libs/*.jar"   # (1)에서 다운로드한 .jar 파일
          target: "/home/ubuntu/app"    # (2단계)에서 EC2에 만들어둔 디렉터리


        # (3) EC2 서버에 접속(SSH)하여 배포 스크립트 실행
      - name: SSH into EC2 and Deploy
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.AWS_HOST }}
          username: ${{ secrets.AWS_USERNAME }}
          key: ${{ secrets.AWS_SSH_KEY }}

          script: |
            set -euxo pipefail
            echo "--- 배포 시작 ---"
            APP_DIR="/home/ubuntu/app"
            cd "$APP_DIR"
            
            # =========================================================
            # ▼ Docker Compose: ES/Kibana 설정
            # =========================================================
            echo "--- Docker 설치 확인 및 설치 ---"
            # 'command -v'로 docker가 설치되어 있는지 확인
            if ! command -v docker &> /dev/null
            then
            echo "Docker를 찾을 수 없습니다. 설치를 시작합니다."
            sudo apt-get update
            sudo apt-get install -y docker.io
            sudo systemctl start docker
            sudo systemctl enable docker
            # (선택) sudo 없이 docker를 실행하기 위한 권한 (권장)
            # sudo usermod -aG docker $USER 
            # (새 그룹 적용을 위해 재접속이 필요할 수 있어 GHA 스크립트에선 복잡할 수 있음)
            else
            echo "Docker가 이미 설치되어 있습니다."
            fi
    
            echo "--- (신규) Docker Compose 설치 확인 및 설치 ---"
            # 'command -v'로 docker-compose가 설치되어 있는지 확인
            if ! command -v docker-compose &> /dev/null
            then
            echo "docker-compose를 찾을 수 없습니다. 설치를 시작합니다."
            sudo apt-get update
            sudo apt-get install -y docker-compose
            else
            echo "docker-compose가 이미 설치되어 있습니다."
            fi
          
            echo "--- Docker: .env 파일 생성 (ES 비밀번호) ---"
            echo "ELASTIC_PASSWORD=${{ secrets.ELASTIC_PASSWORD }}" > .env
    
            echo "--- Docker: ES 및 Kibana 시작 ---"
            docker-compose up -d --build
    
            echo "--- Elasticsearch: 'nori' 플러그인 설치 시도 ---"
            echo "Elasticsearch 컨테이너 시작 대기 (30초)..."
            sleep 30
            
            docker exec es-container /usr/share/elasticsearch/bin/elasticsearch-plugin install analysis-nori || true
            
            echo "--- Elasticsearch: 'nori' 적용을 위해 재시작 ---"
            docker-compose restart elasticsearch
    
            echo "--- Docker 설정 완료 ---"

            echo "--- 새 .jar 찾기 (plain 제외) ---"
            JAR_FILE=$(ls build/libs/*.jar 2>/dev/null | grep -v 'plain' | head -n 1 || true)
            if [ -z "$JAR_FILE" ]; then
              echo "오류: 실행 가능한 .jar 파일을 찾을 수 없습니다."
              exit 1
            fi
            echo "배포할 파일: $JAR_FILE"

            echo "--- 기존 프로세스 PID 조회 (JAR 파일명 기준) ---"
            # JAR 파일명만 추출
            JAR_NAME=$(basename "$JAR_FILE")
            PID=$(pgrep -f "$JAR_NAME" || true)
            echo "찾은 PID: ${PID:-none}"

            if [ -n "$PID" ]; then
              echo "SIGTERM 보내기..."
              kill -15 $PID || true
              sleep 10
              echo "강제 종료(SIGKILL) 시도..."
              kill -9 $PID || true
            fi

            echo "--- 새 서버 시작 (환경변수와 함께) ---"
            nohup /usr/bin/java \
              -Dspring.datasource.url='${{ secrets.DB_URL }}' \
              -Dspring.datasource.username='${{ secrets.DB_USERNAME }}' \
              -Dspring.datasource.password='${{ secrets.DB_PASSWORD }}' \
              
              # ▼▼▼ [신규] Elasticsearch ID/PW 주입 ▼▼▼
              -Dspring.data.elasticsearch.username=elastic \
              -Dspring.data.elasticsearch.password='${{ secrets.ELASTIC_PASSWORD }}' \
              
              -jar "$JAR_FILE" > $APP_DIR/server.log 2>&1 &
            
            disown
            echo "서버 시작 명령 전송 완료. 로그: $APP_DIR/server.log"
            echo "--- 배포 완료 ---"
